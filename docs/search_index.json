[["index.html", "An RNA-seq Data Analysis Protocol Preface", " An RNA-seq Data Analysis Protocol Wei Shi 2021-01-18 Preface This tutorial describes a RNA-seq analysis protocol that can be used to analyse Bulk RNA-seq data on the ONJCRI Bioinformatics server. The guide provides a brief discussion and examples of the steps involved in the analysis of Bulk RNA-seq data, from raw data through to differential expression analysis. "],["intro.html", "1 Overview", " 1 Overview Discovering differentially expressed genes is one of the most important applications of RNA sequenicng technologies. This RNA-seq analysis protocol provides step-by-step procedures for a successful analysis of an RNA-seq dataset. The protocol can be applied to RNA-seq data generated from any species that has a reference genome and an annotation of genes and it can be applied to both small and large RNA-seq experiments. This protocol comprises three major steps including read mapping, read counting and statistical testing (Fig. 1). Read mapping and counting are performed using Rsubread package (Liao, Smyth, and Shi 2019) and statistical testing is carried out using limma package (Ritchie et al. 2015). Read mapping. Read mapping is the first step in an RNA-seq analysis. In this step, an index for the reference genome will be first built using buildindex() function and then reads will be aligned to the genome using the align() function (Liao, Smyth, and Shi 2019, 2013b). Index building is a one-off operation. The built index can be reused in future RNA-seq analyses. Read mapping results generated from align() are saved to BAM or SAM format files. align() also returns a mapping summary including percentages of mapped reads, uniquely mapped reads and multi-mapping reads. Read counting After read mapping is completed, mapped reads can then be counted to genes using the featureCounts() function (Liao, Smyth, and Shi 2013a). Other than read mapping data, a gene annotation must be provided to featureCounts() for read counting. Rsubread package includes inbuilt gene annotations for human and mouse genomes. These annotations were constructed based on the NCBI RefSeq gene annotation database (O’Leary et al. 2015). Gene annotations for other species can be downloaded from NCBI RefSeq or other databases. featureCounts() (Shi, Liao, and Jenny Dai 2020) returns a count table which includes read counts for each gene in each library. It also returns other information such as counting summary for each library and gene length. Normalization After read counts are generated, the voom() function in limma will be used to convert raw counts to counts per million (CPM), estimate the mean-variance relationship and compute observation levelweights (Law et al. 2014). The quantile normalization will also be applied to the data. Linear models are then fitted to the normalized data using lmFit() function. Empirical Bayes moderated t-statistic will be used to test the statistical significane of gene expression changes (Smyth 2004). This test is performed using the eBayes() function in limma (Smyth et al. 2020). The output of statistical testing will include differentially expressed genes if any are found. References "],["prerequisites.html", "2 Prerequisites 2.1 Data 2.2 SOFTWARE", " 2 Prerequisites Before you get started with the rest of the analysis, it is important that you have the necessary data and software that will be used in this analysis. 2.1 Data RNA-seq data An RNA-seq dataset generated in a published study (8) is used as an example dataset in this protocol. A text file called “Targets.txt”, which includes relevant sample information, can also be found in this directory. Reference genome data A FASTA-format file including all chromosomal sequences of the GRCm38/mm10 genome was also saved in ‘Workshop_RNAseq’ directory on Z drive. 2.2 SOFTWARE The following software tools should be installed on a UNIX server and on your laptop: R (https://www.r-project.org) Rsubread (http://bioconductor.org/packages/release/bioc/html/Rsubread.html) limma (http://bioconductor.org/packages/release/bioc/html/limma.html) edgeR (http://bioconductor.org/packages/release/bioc/html/edgeR.html) org.Mm.eg.db (http://bioconductor.org/packages/release/data/annotation/html/org.Mm.eg.db.html) statmod (https://CRAN.R-project.org/package=statmod) Consult the R Project website for the installation of R (https://www.r-project.org/) (R Core Team 2020). Make sure the latest release version of R is downloaded and installed. After R is installed, launch R and type the following commands to install Rsubread, limma, edgeR, org.Mm.eg.db and statmod: if (!requireNamespace(&quot;BiocManager&quot;, quietly = TRUE)) install.packages(&quot;BiocManager&quot;) BiocManager::install(c(&quot;Rsubread&quot;,&quot;limma&quot;,&quot;edgeR&quot;,&quot;org.Mm.eg.db&quot;)) install.packages(&quot;statmod&quot;) Alternatively, you may use Rstudio to run this protocol. References "],["running-environment.html", "3 Running Environment 3.1 RStudio 3.2 UNIX server + laptop 3.3 Laptop only", " 3 Running Environment 3.1 RStudio 3.2 UNIX server + laptop 3.3 Laptop only Run your entire RNA-seq analysis on your laptop. If you choose this option, you should build a low-memory index (split index) for the reference genome before performing read mapping. "],["rna-seq-analysis-protocol.html", "4 RNA-SEQ analysis protocol", " 4 RNA-SEQ analysis protocol Please note that your analysis results might be slightly different from those shown in this protocol due to software version differences. We first change the working directory to the Workshop folder setwd(&quot;Workshop_RNAseq/&quot;) Build index for a reference genome Step 1 Start an R session and build an index for the reference genome GRCm38/mm10. The created index files will be saved to the current working directory. This index only needs to be built once and it can be reused in future RNA-seq data analyses. TIMING ~40 mins library(Rsubread) buildindex(&quot;mm10_reference&quot;, &quot;mm10.fa&quot;) If you build an index on a laptop, it is recommended to build a split index. The amount of requested memory should be roughly half of the total memory available on your laptop. For example, if your laptop has 8GB memory, you may use the following command to build a split index with 4GB memory usage. TIMING ~90 mins buildindex(&quot;mm10_reference&quot;, &quot;mm10.fa&quot;, indexSplit = TRUE, memory = 4000) Create sample-related information and evaluate quality of sequencing TIMING ~ 3 mins Step 2 Create a tab-delimited text file that contains sample-related information such as FASTQ file names, sample names and cell types. For convenience, a file called “Targets.txt” has already been created for this dataset and we read in this file: library(limma) targets &lt;- readTargets(&quot;Targets.txt&quot;) targets ## Library Sample CellType ## 1 CIS_1_C6AG6ANXX_ATCACG_L008_R1.fastq.gz CIS_rep1 CIS ## 2 CIS_2_C6AG6ANXX_CGATGT_L008_R1.fastq.gz CIS_rep2 CIS ## 3 WT_3_C6AG6ANXX_TTAGGC_L008_R1.fastq.gz WT_rep1 WT ## 4 WT_4_C6AG6ANXX_TGACCA_L008_R1.fastq.gz WT_rep2 WT Step 3 Choose one of the libraries and examine the Phred quality scores of read bases at each read position. Boxplots of Phred scores are generated for each base position. qs &lt;- qualityScores(targets$Library[1], offset = 33) boxplot(qs, xlab = &quot;Base position&quot;, ylab = &quot;Phred score&quot;, cex = 0.1) Align and count reads TIMING ~6 min per library Step 4 Map sequence reads to mouse genome GRCm38/mm10. It is recommended to provide gene annotation to the read mapping. Mapped reads are saved to BAM files and a mapping summary is returned to R after read mapping is completed. align.outfiles &lt;- paste(targets$Sample, &quot;bam&quot;, sep = &quot;.&quot;) align.summary &lt;- align( &quot;mm10_reference&quot;, targets$Library, output_file = align.outfiles, nthreads = 10, useAnnotation = TRUE, annot.inbuilt = &quot;mm10&quot; ) align.summary Step 5 Assign reads to overlapping genes and generate an R object that contains a count table, gene annotation and counting summary. The count table contains number of reads assigned to each gene in each library. The gene annotation includes Entrez gene identifier, chromosomal coordinates of gene exons and gene length (total number of non-overlapping exonic bases each gene has). The counting summary gives the number of successfully assigned reads in each library and also numbers of reads that failed to be assigned due to filtering. The ‘Status’ column in this summary includes a ‘Assigned’ category and also multiple ‘Unassigned’ categories corresponding to different read filters used in counting. counts.gene &lt;- featureCounts(align.outfiles, &quot;mm10&quot;, nthreads = 10) counts.gene$stat Save R data and switch from the UNIX server to a personal computer TIMING &lt; 1 min (Steps 6 and 7 can be skipped if you run the protocol using ‘RStudio (2672)’ or laptop only) Step 6 (optional) Save all generated R objects to a file and then copy the file to your personal computer. save.image(&quot;Counts.rdata&quot;) Step 7 (optional) Launch R on your personal computer and load R objects from the copied file. load(&quot;Counts.rdata&quot;) Perform differential expression analysis TIMING &lt; 1 min Step 8 Load required libraries. library(limma) library(edgeR) library(statmod) suppressMessages(library(org.Mm.eg.db)) Step 9 Create a design matrix. ct &lt;- factor(targets$CellType) design &lt;- model.matrix(~0 + ct) colnames(design) &lt;- levels(ct) Step 10 Map Entrez gene identifiers to gene symbols and create an R object containing annotation data for each gene. The annotation data include Entrez gene identifier, gene symbol and gene length. tmp &lt;- org.Mm.egSYMBOL entrez_symbol &lt;- as.list(tmp[mappedkeys(tmp)]) entrez_symbol &lt;- sapply(entrez_symbol, function(x) x[1]) genes &lt;- counts.gene$annotation$GeneID m &lt;- match(genes, names(entrez_symbol)) genes &lt;- data.frame( EntrezID = genes, Symbol = entrez_symbol[m], Length = counts.gene$annotation$Length, stringsAsFactors = FALSE ) Step 11 Remove from analysis those genes that did not express, or expressed at a very low level, in all cell types. Here we require a gene to have a CPM value greater than 0.5 in at least two libraries to be included in the subsequent analysis. The reason we require at least two libraries is because there are two biological replicates generated for each sample in this dataset. keep &lt;- rowSums(cpm(counts.gene$counts) &gt; 0.5) &gt;= 2 sum(keep) ## [1] 11969 Step 12 Transform count data to log2-cpm, estimate the mean-variance relationship and compute observation-level weights. Log2-cpm expression values of genes are then normalized using the quantile method and converted to log2-rpkm (log2 reads per kilobases of exons per million reads) values. y &lt;- voom(counts.gene$counts[keep, ], design, normalize.method = &quot;quantile&quot;) y$genes &lt;- genes[keep, ] y$E &lt;- y$E - log2(y$genes$Length / 1000) Step 13 Cluster samples via multidimensional scaling. plotMDS(y, labels=targets$CellType) Step 14 Fit linear models to genes and perform statistical testing to discover differentially expressed genes. A contrast matrix is constructed to specify the comparisons between samples. The empirical Bayes moderated t-statistic is used to assess the differential expression of genes. A FDR (false discovery rate) cutoff is applied for calling differentially expressed genes. For this analysis, an FDR cutoff of 0.05 was applied (default cutoff value in decideTests()). fit &lt;- lmFit(y, design) contr &lt;- makeContrasts(CISvsWT = CIS - WT, levels = design) fit.contr &lt;- eBayes(contrasts.fit(fit, contr)) dt &lt;- decideTests(fit.contr) summary(dt) ## CISvsWT ## Down 1662 ## NotSig 8788 ## Up 1519 Step 15 Display top 10 most differentially expressed genes: options(digits=2) topTable(fit.contr) ## EntrezID Symbol Length logFC AveExpr t P.Value adj.P.Val ## 12700 12700 Cish 2161 -3.5 4.705 -27 2.1e-08 7.4e-05 ## 69368 69368 Wdfy1 4714 -2.6 1.999 -21 1.6e-07 3.1e-04 ## 21638 21638 Trgv4 419 3.8 3.666 17 5.9e-07 8.8e-04 ## 436468 436468 Trav15d-1-dv6d-1 349 4.2 3.098 17 4.8e-07 8.1e-04 ## 22290 22290 Uty 5228 -11.0 -2.841 -31 9.7e-09 7.4e-05 ## 26908 26908 Eif2s3y 1767 -12.2 -0.086 -27 2.4e-08 7.4e-05 ## 26900 26900 Ddx3y 4640 -11.5 -1.825 -27 2.5e-08 7.4e-05 ## 20592 20592 Kdm5d 5471 -10.6 -2.515 -25 4.0e-08 9.6e-05 ## 59310 59310 Myl10 880 2.6 3.140 14 2.1e-06 2.3e-03 ## 13508 13508 Dscam 7481 -2.3 0.022 -14 2.3e-06 2.3e-03 ## B ## 12700 10.1 ## 69368 8.2 ## 21638 6.6 ## 436468 6.3 ## 22290 6.1 ## 26908 6.0 ## 26900 6.0 ## 20592 5.8 ## 59310 5.7 ## 13508 5.6 Step 16 Save all differentially expressed genes to a file. de.genes &lt;- topTable(fit.contr, coef=&quot;CISvsWT&quot;, p.value=0.05, n=Inf) write.csv(de.genes, file=&quot;DE_genes.csv&quot;, row.names=FALSE) "],["more-details-on-the-protocol.html", "5 More details on the protocol 5.1 Sequencing quality 5.2 Gene annotation 5.3 Index building 5.4 Read mapping 5.5 Read counting 5.6 Gene filtering 5.7 Sample clustering 5.8 Statistical testing of differential expression", " 5 More details on the protocol 5.1 Sequencing quality Sequencing output from a sequencer is stored in one or more FASTQ-format files. Each FASTQ file contains nucleotide sequences and sequencing quality strings for the reads generated from a library. The quality string for a read has the same length as the read sequence and each letter in the string encodes the sequencing quality score of the corresponding read base. The ASCII code of a letter is equal to the Phred quality score of the read base plus an integer offset. A Phred quality score denotes the sequencing quality of a read base. It is computed as −10 x log10P, where P is the probability that a read base is incorrectly called The qualityScores() function in Rsubread extracts quality strings from a FASTQ file and returns the Phred scores in a data matrix object in which rows are reads and columns are base positions. Distribution of Phred scores at each base position can be viewed by using the boxplot() function. For reads generated by the popular Illumina sequencers such as HiSeq and NextSeq, sequencing quality is usually lower at the two ends of the read (particular at the 3’ end) compared to the middle part of the read. The vast majority of read bases in a FASTQ file are expected to have a Phred score greater than 13 (corresponding to P value of 0.05). Fig. 2 shows the boxplots of quality scores in a library that was sequenced in 2015 by an Illumina HiSeq 2000 sequencer. The boxplots show that this dataset has a high sequencing quality. Box 1 | The Simplified Annotation Format (SAF) The Simplified Annotation Format is defined in Rsubread and this format is used by featureCounts to counts reads to genes or other genomic features. This format only includes five compulsory columns: ‘GeneID’, ‘Chr’, ‘Start’, ‘End’ and ‘Strand’. Below is an example of SAF annotation for two RefSeq genes with Entrez gene identifiers 497097 and 100503874. GeneID Chr Start End Strand** 497097 chr1 3204563 3207049 - 497097 chr1 3411783 3411982 - 497097 chr1 3660633 3661579 - 100503874 chr1 3637390 3640590 - 100503874 chr1 3648928 3648985 - Gene identifiers included in the column ‘GeneID’ can be integer numbers (eg. Entrez gene identifiers) or character strings (eg. gene symbols). 5.2 Gene annotation The Rsubread package contains inbuilt gene annotation for human and mouse, making it convenient to process RNA-seq data generated from human or mouse samples. This annotation was generated based on the NCBI RefSeq gene annotation. In this annotation, overlapping exons from the same gene were merged to form a single exon covering all overlapping exons. The inbuilt annotations can be used in both read counting and read mapping. The inbuilt annotations are in SAF format (Box 1). They can be retrieved using the getInBuiltAnnotation() function in Rsubread. Alternatively, external gene annotations such as those generated in Ensembl database (9) or GENCODE database (10) can be used for counting and mapping. Formats of external gene annotation that are accepted by Rsubread functions include GTF and GFF3 (https://genome.ucsc.edu/FAQ/FAQformat.html#format4). 5.3 Index building An index built for a reference genome contains a large hash table, which stores chromosomal locations of subreads (16bp mers) extracted from the reference genome. With the hash table, subreads extracted from a read can be quickly mapped to the genome via a quick search (hashing) in the table. Candidate mapping locations of the read will then be determined by the voting of mapped subreads and final mapping location will be determined by further evaluation of candidate mapping locations. The index can be built as either a full index or a gapped index. A full index contains subreads extracted from every base location of the genome, whereas a gapped index contains subreads extracted from every three bases in the genome. The use of a full index will make read mapping faster, but it also causes more computer memory to be used. Full index and gapped index can be further split into blocks. This can reduce memory usage but mapping time will increase on the other hand. See Box 2 for more information on gapped index and split index. By default, buildindex() constructs a single-block full index for a reference genome. This allows maximum mapping speed to be achieved. To our knowledge, Rsubread is the only tool that allows users to tune the amount of memory used to achieve a desired balance between memory consumption and speed in read mapping. This flexibility allows Rsubread to be run on various computing platforms. 5.4 Read mapping After an index is successfully built, sequencing reads can then be mapped to the reference genome via the align() function. Reads are mapped via a two-pass procedure. In the first pass, subreads (seeds) are extracted from each read and their locations in the genome are quickly determined by looking up the hash table included in the index. Mapped subreads then ‘vote’ for mapping locations of the read. This ‘seed-and-vote’ strategy has been demonstrated to be more efficient and accurate than the conventional ‘seed-and-extend’ strategy (Liao, Smyth, and Shi 2019, 2013b). Indels will also be discovered in this step. In the second pass, reads are re-aligned to the genome to determine their final mapping location by taking into account indels identified from the first pass. Note that align() does not perform full alignment for exon-spanning reads. It only aligns such reads to the exon they most overlap with. Read bases overlapping other exons in such reads are soft-clipped. However this partial alignment is sufficient for RNA-seq expression quantification at the gene level because reads can be confidently assigned to one of the exons in the gene. To fully align exon-spanning reads, the subjunc() function in Rsubread can be used. subjunc() is slower than align(), but it is still computationally competitive. subjunc() is also a two-pass aligner. However it not only collects indels in its first pass, it also collects exon splicing sites. In its second pass, it will use detected exon splicing sites to further improve the mapping of exon-spanning reads. Box 2 | Build an index with less memory usage A gapped index can be built to reduce the index size. Size of a gapped index is only one third of size of the full index. Use of a gapped index could save more than 50% of memory used in read mapping. During read mapping, the memory contains the index and also other data such as chromosomal sequences, read sequences and intermediate mapping data. For human or mouse genome, size of the full index is ~15GB and size of the gapped index is 5GB. During read mapping, ~18GB of memory is consumed when full index is used and ~8GB when gapped index is used. Below is the command for building a gapped index: &gt; buildindex(&quot;mm10_reference&quot;, &quot;mm10.fa&quot;, gappedIndex=TRUE) The full index and gapped index can be split into blocks to further control the amount of memory to be used. Users can specify the maximum memory allowed and buildindex() will automatically split the index into required number of blocks. The index blocks will be loaded to memory sequentially during read mapping. The more blocks an index is split into, the smaller the memory required for read mapping. However the read mapping time will also increase. The following command builds a full index that is split into multiple blocks to achieve a memory use no more than 4000MB. &gt; buildindex(&quot;mm10_reference&quot;, &quot;mm10.fa&quot;, indexSplit=TRUE,memory=4000) Rsubread aligners are the first to use the two-pass strategy to improve the mapping quality of RNA-seq reads. This strategy has later been adopted by other RNA-seq aligners. Mapping results from align() include both mapped and unmapped reads. The results are saved to files in BAM or SAM format. Indels identified in the mapping are saved to VCF-format files. align() also returns an R object that contains mapping statistics for each library. Percentage of successfully mapped reads in a library is affected by multiple factors including sequencing quality, read length, paired-end or single-end, quality of reference sequences and aligner setting. For the single-end reads generated from the latest Illumina HiSeq/NextSeq/NovaSeq sequencers, align() typically reports around 80-90 percent of mapped reads. If paired-end reads are provided, the mapping percentage is expected to be slightly higher. 5.5 Read counting After read mapping is completed, mapped reads can be counted to genes by featureCounts() function in Rsubread. featureCounts() compares chromosomal coordinates of mapped reads with chromosomal coordinates of exons in each gene. CIGAR (Concise Idiosyncratic Gapped Alignment Report) string of each mapped read is analyzed so that read assignment can be done precisely. featureCounts() provides a wide range of counting options. For example, overlap between a read and an exon can be determined based on the number of overlapping bases, fraction of overlapping bases and number of non-overlapping bases. Multi-mapping reads can be excluded from counting, or only have their primary alignment counted or have all their alignments counted. Similarly, for multi-overlapping reads that overlap more than one gene they can be excluded from counting or be counted to all their overlapping genes. featureCounts() accepts both name-sorted and location-sorted reads. It can output counting details for each individual read. featureCounts() returns an R object that includes a count table, gene annotation and counting statistics. Percentage of successfully assigned reads is affected by many factors including cell type, annotation quality and mRNA purity. The counting percentage could be highly variable between experiments, even for well annotated genomes such as human and mouse genomes. Typically around 50 – 90 percent of mapped reads are assigned to genes in a mouse experiment. For the RNA-seq data used in this protocol, ~70 percent of reads were successfully assigned. 5.6 Gene filtering Genes that do not express or express at a very low level in all the samples are filtered out from analysis. Such genes are very hard to handle in the statistical testing. Typically ~50 percent of genes are excluded in the analysis of mouse RNA-seq data. For the RNA-seq data used in this protocol, 58 percent of genes were removed from analysis. 5.7 Sample clustering Examining the clustering of samples is a useful way to check the quality of samples. Sample replicates should cluster together and different sample types should separate from each other. 5.8 Statistical testing of differential expression A rigorous false discovery rate (FDR) threshold should be applied when calling differentially expressed genes. This threshold is usually 0.05, but it might be relaxed to 0.1 or even 0.15 in some circumstances. The treat() function in limma might be considered for testing against a fold change of gene expression. References "],["references.html", "References", " References "]]
